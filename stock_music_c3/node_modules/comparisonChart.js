'use strict';

var d3 = require('d3');
var sl = require('sl');
sl.series.comparison = require('comparisonSeries');
sl.svg.gridlines = require('gridlines'); 
var Stock = require('stock');

var comparisonChart = function (zoomMethod, data, transport, stocks, step_array) {
    var fromDate = data[0].data[0].date,
        toDate = data[0].data[89].date;

    var xScale = d3.time.scale(),
        yScale = d3.scale.linear();

    var xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom')
        .ticks(8);

    var yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left')
        .ticks(5)
        .tickFormat(d3.format('%'));

    var series = sl.series.comparison()
        .xScale(xScale)
        .yScale(yScale);

    var gridlines = sl.svg.gridlines()
        .xScale(xScale)
        .yScale(yScale)
        .xTicks(8)
        .yTicks(8);

    var zoom = d3.behavior.zoom()
        .x(xScale)
        .scaleExtent([1, 50])
        .on('zoom', function(){
            zoomed(transport, step_array, stocks);
        })
        .on('zoomend', zoomend);

    var margin = {top: 75, right: 100, bottom: 200, left: 100},
        width = window.innerWidth - margin.left - margin.right,
        height = window.innerHeight - margin.bottom;

    if(d3.select("svg")){
        d3.select("svg")
        .remove();
    }
    // Create svg element
    var svg = d3.select('#chart')
        .classed('chart', true)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

    // Ceate chart
    var g = svg.append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    // Create plot area
    var plotArea = g.append('g');
    plotArea.append('clipPath')
        .attr('id', 'plotAreaClip')
        .append('rect')
        .attr({ width: width, height: height });
    plotArea.attr('clip-path', 'url(#plotAreaClip)');

    // Create zoom pane
    plotArea.append('rect')
        .attr('class', 'zoom-pane')
        .attr('width', width)
        .attr('height', height)
        .call(zoom);

    // Set scale domain

    xScale.domain([fromDate, toDate]);

    var xWidth = xScale(toDate);
    xScale.domain([xScale.invert(xWidth / 8), xScale.invert(xWidth - (xWidth / 32))]);

    // Set scale ranges
    xScale.range([0, width]);
    yScale.range([height, 0]);

    // Reset zoom.
    zoom.x(xScale);

    // Draw series.
    plotArea.append('g')
        .attr('class', 'series')
        .datum(data)
        .call(series);

    // g.append('circle')
    //     .data(data)
    //     .enter()
    //     .append("circle");

    // Draw axes
    g.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis);

    g.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    // Draw gridlines
    plotArea
        .call(gridlines);

    var left_bounds = 0, right_bounds = 80;

    function zoomed(transport, stepArray, stocks) {

        var xDomain = xScale.domain();
        var xRange = xScale.range();
        var translate = zoom.translate()[0];

        var bpm = Math.abs(xDomain[0] - xDomain[1]) / 9004668750 * 84 + 60

        transport.setBpm( bpm );

        // var stepRange = Math.round((Math.max(4842240306, Math.abs(xDomain[1] - xDomain[0])) - 4842240306 ) / 4346197194 * 82 + 8);
        
        for(var i = 0; i < stocks[0].data.data.length; i++){

            if(Math.abs(stocks[0].data.data[i].date - xDomain[0]) < 10000000) {
                left_bounds = i;
                // console.log('setting left bounds to: ', left_bounds);
            }
            if(Math.abs(stocks[0].data.data[i].date - xDomain[1]) < 10000000) {
                right_bounds = i;
                // console.log('setting right bounds to: ', right_bounds);                
            }

        }

        var step_range = right_bounds - left_bounds;

        // console.log(step_range);

        for(var s = 0; s < 8; s++){
            stepArray[s] = (s * Math.round(step_range / 8) + left_bounds);
        }

        // console.log(stepArray);

        if (xDomain[0] < fromDate) {
            translate = translate - xScale(fromDate) + xRange[0];
        } else if (xDomain[1] > toDate) {
            translate = translate - xScale(toDate) + xRange[1];
        }
        zoom.translate([translate, 0]);

        if (zoomMethod === "Geometric") {
            series.geometricZoom(g.select('.series'), translate, d3.event.scale, transport);
        } else {
            g.select('.series')
                .call(series);
        }

        g.select('.x.axis')
            .call(xAxis);

        g.select('.y.axis')
            .call(yAxis);

        plotArea
            .call(gridlines);
    }

    function zoomend() {
    }
};

module.exports = comparisonChart;
